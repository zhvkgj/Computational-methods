% функция поиска наилучшего приближения
%   произвольной функции f
% принимает функцию f, для которой требуется найти
%   полином наилучшего приближения p = ax + b,
%   интервал, на котором заданна фукнция,
% возвращает полином p = ax + b,
%   реализующий наилучшее приближение,
%   массив значений исходной функции,
%   массив значений хорды,
%   массив значений касательной
%   наилучшее приближение
function [p_arr, f_arr, h_arr, k_arr, bst] = BestEstimatePolinom(f, x)
% размер исходного интервала
n = size(x, 2);
% коэффициенты уравнения хорды
h1 = (f(x(n)) - f(x(1))) / (x(n) - x(1));
h2 = (x(1) * f(x(n)) - x(n) * f(x(1))) / (x(1) - x(n));
% значения исходной функции на заданном интервале
f_arr = zeros(1, n);
% значения хорды на заданном интервале
h_arr = zeros(1, n);
% значения касательной на заданном интервале
k_arr = zeros(1, n);
% заполнение массива значений исходной функции
%   и значений хорды на исходном интервале
for i = 1:n
    f_arr(i) = f(x(i));
    h_arr(i) = h1 * x(i) + h2;
end
% поиск точек, через которые можно провести касательную
res = GetAlternancePoints(f_arr, h_arr, n);
% заполнение массива значений касательной
for i = 1:n
    if (f_arr(res(3)) > h_arr(res(3))) 
        k_arr(i) = h_arr(i) + res(1);
    else
        k_arr(i) = h_arr(i) - res(1);
    end
end
% вычисление двух точек для нахождения полинома
if (f_arr(res(3)) > h_arr(res(3))) 
    y1_p = h_arr(1) + res(1) / 2;
    y2_p = h_arr(res(3)) + res(1) / 2;
else
    y1_p = h_arr(1) - res(1) / 2;
    y2_p = h_arr(res(3)) - res(1) / 2;
end
% массив коэффициентов уравнения полинома,
%   реализующего наилучшее приближение
p_arr = zeros(1, 2);
% подсчет коэффициентов уравнения полинома
p_arr(1) = (y2_p - y1_p) / (x(res(3)) - x(1));            
p_arr(2) = (x(1) * y2_p - x(res(3)) * y1_p) / (x(1) - x(res(3)));
% наилучшее приближение
bst = res(1);




